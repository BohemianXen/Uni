<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Cube Manipulation</title>
		<style>
			body {margin: 0;}
			canvas {width: 100%; height: 100%}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
                <script src="js/OBJLoader.js"></script>
		<script>
			// Scene Setup
                        var scene = new THREE.Scene();
                        var sceneBackground = scene.background;
                        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                        var renderer = new THREE.WebGLRenderer();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        document.body.appendChild(renderer.domElement);
                        
                        
                        // Lights Setup
                        var ambientLight = new THREE.AmbientLight(0x404040);
			scene.add(ambientLight);
                        var lights = [];
			lights[0] = new THREE.PointLight(0xffffff, 1, 0);
			lights[1] = new THREE.PointLight(0xffffff, 1, 0);
			lights[2] = new THREE.PointLight(0xffffff, 1, 0);

			lights[0].position.set(0, 200, 0);
			lights[1].position.set(100, 200, 100);
			lights[2].position.set(-100, -200, -100 );
                        
                        for (var i = 0; i < lights.length; i++) {
                            scene.add(lights[i]);
                        }
                        
  
                        // Event Listeners
                        document.addEventListener("keydown", onKeyDown); //TODO: Pausing cube blocks other events until resumption
                        document.addEventListener("wheel", onWheelScroll);
                        document.addEventListener("mousedown", onMouseDown);
                        document.addEventListener("mousemove", onMouseMove);
                        document.addEventListener("mouseup", onMouseUp);
                        
                        
                        // Default Camera Positioning
                        var defaultCamera = camera.clone();
                        var defaultCameraPos = [2, 1, 5];
                        var defaultLookAt = new THREE.Vector3(0.0031250000000000444, -0.22544951590594753, 0.9742498396986135);
                        defaultCamera.position.x = defaultCameraPos[0]; 
                        defaultCamera.position.y = defaultCameraPos[1];
                        defaultCamera.position.z = defaultCameraPos[2];
                        var resetCamera = function () {
                            camera = defaultCamera.clone(); 
                            camera.lookAt(defaultLookAt);
                        };
                        
                        resetCamera();  
                        
                        
                        // Object States                    
                        var States = {
                            rotating: true,
                            vertexRendering: false,
                            edgeRendering: false, 
                            faceRendering: true, // Inverted initialisation
                            textureRendering: false,
                            orbiting: false,
                            objectLoaded: false, 
                            cubeDisplayed: false,
                            objectLoadedDisplayed: false
                        };
                        
                        var ActiveObject = { 
                            selected: null,
                            points: null                       
                        };
                        
                        var updateSelectedObject = function (newSelectedObject){
                             ActiveObject.selected = newSelectedObject;
                        };
                                               
                        var updateActivePoints = function (newPoints){
                             ActiveObject.points = newPoints;
                        };
                                      
                        // Cube Setup
                        var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);         
                        var cubeColor = new THREE.Color(0x00fB8B);
                        var cubeMaterial = new THREE.MeshPhongMaterial({color: cubeColor, vertexColors: THREE.VertexColors , flatShading: true});
                        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                       
                        scene.add(cube);
                        updateSelectedObject(cube);
                        States.cubeDisplayed = true;
                        
                        // Axes Setup                
                        var xAxisGeometry = new THREE.Geometry();
                        var yAxisGeometry = xAxisGeometry.clone();
                        var zAxisGeometry = xAxisGeometry.clone();
                        var xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
                        var yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                        var zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
                        var axisLength = 4;
                        
                        xAxisGeometry.vertices.push(
                                new THREE.Vector3(0, 0, 0),
                                new THREE.Vector3(axisLength, 0, 0)
                        );
                
                        yAxisGeometry.vertices.push(
                                new THREE.Vector3(0, 0, 0),
                                new THREE.Vector3(0, axisLength, 0)
                        );
                              
                        zAxisGeometry.vertices.push(
                                new THREE.Vector3(0, 0, 0),
                                new THREE.Vector3(0, 0, axisLength)
                        );
                        
                        var xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
                        var yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
                        var zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
                        
                        scene.add(xAxis, yAxis, zAxis);       
                       
                        
                        // Cube Rotation
                        var animationID; 
                        var rotationStep = 0.01;
                        
                        var rotateX = function () {
                            var obj = ActiveObject.selected;
                            animationID = requestAnimationFrame(rotateX); 
                            obj.rotation.x += rotationStep;
                            if (obj.rotation.x >= 2*Math.PI){
                                 obj.rotation.x = 0;
                                cancelAnimationFrame(animationID); 
                                rotateY();
                            }
                            renderer.render(scene, camera);
                        };
                        
                        var rotateY = function () {
                            var obj = ActiveObject.selected;
                            animationID = requestAnimationFrame(rotateY);
                            obj.rotation.y += rotationStep;
                            if (obj.rotation.y >= 2*Math.PI){
                                obj.rotation.y = 0;
                                cancelAnimationFrame(animationID); 
                                rotateZ();
                            }
                            renderer.render(scene, camera);
                        };  
                        
                        var rotateZ = function () {
                            var obj = ActiveObject.selected;
                            animationID = requestAnimationFrame(rotateZ); 
                            obj.rotation.z += rotationStep;
                            if (obj.rotation.z >= 2*Math.PI){
                                obj.rotation.z = 0;
                                cancelAnimationFrame(animationID); 
                                rotateX();
                            }
                            renderer.render(scene, camera);
                        };
                                                                                     
                        rotateX();
                        States.rotating = true;
                        
                        var toggleAnimation = function () {
                            var obj = ActiveObject.selected;
                            if (States.rotating){
                                cancelAnimationFrame(animationID); 
                            } else {
                                if (obj.rotation.y !== 0){
                                    obj.rotation.x = 0;
                                    obj.rotation.z = 0;
                                    rotateY();
                                } else if (obj.rotation.z !== 0){
                                    obj.rotation.x = 0;
                                    obj.rotation.y = 0;
                                    rotateZ();
                                } else { 
                                    obj.rotation.y = 0;
                                    obj.rotation.z = 0;
                                    rotateX();                                 
                                }
                            }
                            States.rotating = !States.rotating; 
                        };
                           
                        
                        // Render modes 
                        var pointsMaterial = new THREE.PointsMaterial({color: 0xffff00, size:0.05});
                        var cubePoints = new THREE.Points(cubeGeometry, pointsMaterial);
                        
                        updateActivePoints(cubePoints);
                        
                        // TODO: - Cannot enter edge mode from texture mode
                        //       - Cannot enter edge mode from off face mode
                        //       - Revert back to overlayed edge mode
                        var toggleEdges = function (obj) {
                            if (!States.edgeRendering){ 
                                obj.traverse(
                                    function (child) {
                                        if (child.material !== undefined && child.material.isMaterial) { 
                                            child.material.wireframe = true; 
                                        }        
                                    });
                            } else {
                                obj.traverse(
                                    function (child) {
                                        if (child.material !== undefined && child.material.isMaterial) { 
                                            child.material.wireframe = false; 
                                        }        
                                    });
                            }  
                            
                            if (!States.textureRendering) {
                                States.edgeRendering = !States.edgeRendering;
                            }   
                        };
                        
                        // TODO: Fix bugs -> T then F needs second F also a subsquent T does not bring the texture back
                        //                   F then T means T behaves like F
                        var toggleFaces = function (obj) {
                            if (!States.faceRendering){
                                 obj.traverse(
                                    function (child) {
                                        if (child.material !== undefined && child.material.isMaterial) { 
                                            child.material.opacity = 0.0;
                                            child.material.transparent = true;
                                        }        
                                    });
                            } else { 
                                if (States.edgeRendering) { toggleEdges(obj); }
                                obj.traverse(
                                    function (child) {
                                        if (child.material !== undefined && child.material.isMaterial) { 
                                            child.material.opacity = 1.0;
                                            child.material.transparent = false;
                                        }        
                                    });
                            }    
                            States.faceRendering = !States.faceRendering;
                        };     
                        
                        // TODO  - Cannot enter vertices mode from off face mode
                         //      - T -> F -> V -> F -> F now stuck with V=F
                        var toggleVertices = function (obj) {
                        if (!States.vertexRendering){
                                obj.add(ActiveObject.points);
                            } else {
                                obj.remove(ActiveObject.points);
                            }     
                            States.vertexRendering = !States.vertexRendering;   
                        };
                             
                             
                        // Camera Translation    
                        // TODO: Change scrollwheel to zoom on scrollwheel, not z translation
                        var cameraMovementDistance = 0.1;
                        
                        var translateCamera = function (direction)  {
                            switch (direction){
                                case 'left':
                                    camera.translateX(-cameraMovementDistance);
                                    break;
                                case 'up':
                                     camera.translateY(cameraMovementDistance);
                                    break;
                                case 'right':
                                    camera.translateX(cameraMovementDistance);                              
                                    break;
                                case 'down':
                                    camera.translateY(-cameraMovementDistance);
                                    break;
                                case 'forwards':
                                    camera.translateZ(-cameraMovementDistance);
                                    break;
                                case 'backwards':
                                    camera.translateZ(cameraMovementDistance);
                                    break;
                                default:
                                    break;
                            }
                        };
                       
                       
                        // Camera Orbit   
                        var Orbit = {
                            started: false,
                            xFocus: 0, 
                            yFocus: 0,
                            xMove: 0,
                            yMove: 0,
                            radius: -1,
                            lookAtPoint: null
                        };
                        
                        var sqr = val => val*val;
                        var sum = (accumulator, val) => accumulator + val;

                        // TODO: - Fix rotation speed 
                        //       - Zooms out if you drag sideways a bunch
                        //       - Always looks at origin too much         
                        var orbitCamera = function () {
                            if (!Orbit.started){
                                xStart = Orbit.xFocus; yStart = Orbit.yFocus;
                                Orbit.lookAtPoint = screen2Cartesian(xStart, yStart);
                                Orbit.prevX = xStart; Orbit.prevY = yStart;
                                Orbit.radius = Orbit.lookAtPoint.z;
                                Orbit.started = true;                          
                            } else {
                                 if (Orbit.xMove !== 0 || Orbit.yMove !== 0) {
                                    var op1 = screen2Cartesian(Orbit.xFocus, Orbit.yFocus);
                                    var op2 = screen2Cartesian(Orbit.xFocus + Orbit.xMove, Orbit.prevY + Orbit.yMove);
                                    var angle = Math.acos(Math.min(1, dotProduct(op1, op2)));
                                    var orthogonalVector = crossProduct(op1, op2);
                                    
                                    camera.translateX(op2.x - op1.x); // 4)*());
                                    camera.translateY(op2.y - op1.y);
                                    //camera.translateZ(op2.z - op1.z);
                                    //console.log(op1, op2);
                                    console.log(angle);
                                    //console.log(orthogonalVector);

                                    camera.rotateOnAxis(orthogonalVector, angle*2*Math.PI);
                                }
                            }
;
                            camera.lookAt(Orbit.lookAtPoint);
                        };
                        
                        var dotProduct = function (a, b) {
                            var result = [a.x*b.x, a.y*b.y, a.z*b.z];
                            return result.reduce(sum);
                        };
                        
                        var crossProduct = function (a, b) {
                            return new THREE.Vector3(
                                    (a.y*b.z) - (a.z*b.y),
                                    (a.z*b.x) - (a.x*b.z), 
                                    (a.x*b.y) - (a.y*b.x)
                                );
                        };
                            
                        var screen2Cartesian = function (xScreen, yScreen) {
                            var result = [];
                            result.push(-1 + (2*xScreen/window.innerWidth));
                            result.push(-(-1 + (2*yScreen/window.innerHeight))); 
                            var zSquared = sqr(result[0]) + sqr(result[1]);
                            result.push(zSquared);
                            if (Orbit.radius === -1){
                                Orbit.radius = zSquared;
                            }
                            if (zSquared <= Orbit.radius){
                                result[2] = Math.sqrt(zSquared);//Orbit.radius - zSquared);
                            } else {
                                result = result.map(x => x / zSquared);        
                            }
                            return new THREE.Vector3(result[0], result[1], result[2]);  
                        };
                        
                        var cartesian2Spherical = function (cartesianVector3) {
                            var cartesian = [cartesianVector3.x, cartesianVector3.y, cartesianVector3.z];
                            var radius = Math.sqrt(cartesian.map(val => sqr(val)).reduce(sum));
                            var theta = Math.acos(cartesianVector3.z/radius);
                            var phi = Math.atan(cartesianVector3.y/cartesianVector3.x);
                            return [radius, theta, phi];
                        };
                        
                        var spherical2Cartesian = function (spherical) {
                            var radius = spherical[0]; var theta = spherical[1];
                            var phi = spherical[2];
                            var x = radius*Math.sin(theta)*Math.cos(phi);
                            var y = radius*Math.sin(theta)*Math.sin(phi);    
                            var z = radius*Math.cos(theta);         
                            return new THREE.Vector3(x, y, z);  
                        };
   
                        // Cube Texture 
                        var textureNames = ['bronze', 'wire', 'scratched', 'shapes', 'colour', 'water'];
                        var textures = [];
                        var textureLoader = new THREE.TextureLoader();
                        textureLoader.setPath("resources/");
         
                        for (texture in textureNames){                          
                            textures.push(new THREE.MeshBasicMaterial({
                                map: textureLoader.load(textureNames[texture] + '.jpg')
                            }));
                        }
                        
                        var toggleTextures = function (obj) {
                            if (obj === cube){
                                if (!States.textureRendering){
                                    if (States.edgeRendering) { toggleEdges(obj); }
                                    cube.material = textures;
                                } else {
                                    cube.material = cubeMaterial;
                                }
                                States.faceRendering = true;
                                States.textureRendering = !States.textureRendering; 
                                toggleFaces(obj);
                            }
                         };
                         
                         
                        // Object Loading/Switch Active Object
                        var bunny; var bunnyGeometry;
                        var bunnyPoints;
                        var bunnyScaling = 0.15;
                        var bunnyColor = 0xf44298;
                        var bunnyMaterial = new THREE.MeshPhongMaterial({color: bunnyColor});
                        var bunnyPointsMaterial = pointsMaterial.clone();
                        bunnyPointsMaterial.size = 0.01;
                        
                        var objLoader = new THREE.OBJLoader();
                        objLoader.setPath("resources/");

                        var loadObject = function (filename) {                            
                          
                            if (!States.objectLoaded) {
                                objLoader.load(filename,
                                
                                    function(object) {   
                                        bunny = object;                                                  
                                        bunny.traverse(function (child) {
						if (child.isMesh) { 
                                                    child.material = bunnyMaterial;
                                                    bunnyPoints = new THREE.Points(child.geometry, bunnyPointsMaterial);
                                                    //console.log(child);
                                                }        
					});
                                       
                                        bunny.scale.x = bunnyScaling;
                                        bunny.scale.y = bunnyScaling; 
                                        bunny.scale.z = bunnyScaling;

                                        scene.add(bunny);
                                        
                                        States.objectLoadedDisplayed = true;
                                        toggleActiveObject();
                                        States.objectLoaded = true;
                                    }
                                );
                            } else {
                                toggleActiveObject();
                            }
                        }; 
                        
                        var toggleActiveObject = function () {
                           
                            if (ActiveObject.selected === cube) {
                                if (!States.objectLoaded) {
                                    if (States.textureRendering) { toggleTextures(cube); }
                                    if (!States.edgeRendering) { toggleEdges(cube); }                               
                                    if (States.vertexRendering) { toggleVertices(cube); }
                                }
                                
                                updateSelectedObject(bunny);
                                updateActivePoints(bunnyPoints); 
                                States.faceRendering = true;
                                States.edgeRendering = false;
                                
                            } else {
                                updateSelectedObject(cube);
                                updateActivePoints(cubePoints); 
                            }     
                        };
                        
                        var toggleNonActiveObjectDisplay = function () {            
                            if (ActiveObject.selected === cube && States.objectLoaded) {
                                if (States.objectLoadedDisplayed) {
                                    scene.remove(bunny);
                                } else {
                                    scene.add(bunny);
                                }
                                States.objectLoadedDisplayed = !States.objectLoadedDisplayed;
                            } else {
                                if (States.cubeDisplayed) {
                                    scene.remove(cube);
                                } else {
                                    scene.add(cube);
                                }
                                States.cubeDisplayed = !States.cubeDisplayed;
                            }
                        };
                        
                        
                        // Event Handlers
                        
                        // Key press event handler
                        function onKeyDown(e){
                            switch(e.which){
                                // Pause object rotation on spacebar Keydown
                                case 32:
                                    toggleAnimation();
                                    break;
                                // Move camera left on left arrow Keydown
                                    translateCamera('left');
                                    break;
                                // Move camera up on up arrow Keydown
                                case 38:
                                    translateCamera('up');
                                    break;
                                // Move camera right on right arrow Keydown
                                case 39:                            
                                    translateCamera('right');
                                    break; 
                                // Move camera down on down arrow Keydown
                                case 40:
                                    translateCamera('down');
                                    break;                                
                                // Move camera forwards on '+' Keydown; can also be invoked by using the mousewheel
                                case 107:
                                    translateCamera('forwards');
                                    break;                                
                                // Move camera backwards '-' Keydown; can also be invoked by using the mousewheel
                                case 109:
                                    translateCamera('backwards');
                                    break;
                                // Reset camera position on 'r' Keydown
                                case 82:
                                    resetCamera();
                                    break;
                                // Toggle cube edge rendering (inc. primitive triangles) on 'e' Keydown
                                case 69:
                                    toggleEdges(ActiveObject.selected);
                                    break;
                                // Toggle cube faces on 'f' KeyDown
                                case 70: 
                                    toggleFaces(ActiveObject.selected);
                                    break;                      
                                // Toggle cube vertex rendering on 'v' Keydown
                                case 86: 
                                    toggleVertices(ActiveObject.selected);
                                    break;       
                                // Apply textures on 't' Keydown
                                case 84: 
                                    toggleTextures(ActiveObject.selected);
                                    break; 
                                // Load/switch active object on 's' Keydown
                                case 83: 
                                    loadObject('bunny-5000.obj');
                                    break;
                                // Toggle non-active object on 'x' Keydown
                                case 88: 
                                    toggleNonActiveObjectDisplay();
                                    break;
                                default:
                                    break;                            
                            }
                            
                            renderer.render(scene, camera);
                        }
                        
                        // Scroll wheel event handler 
                        // Used to zoom camera in and out via the scroll wheel
                        function onWheelScroll (e){                        
                           if (e.wheelDelta > 0){
                                translateCamera('forwards');
                            } else {
                                translateCamera('backwards');
                            }
                            //console.log(camera.zoom);
                        }
                        
                        function onMouseDown (e){
                            if (e.which === 1){
                                Orbit.xFocus = e.x; Orbit.yFocus = e.y;
                                States.orbiting = true;
                            }
                        }
                        
                        function onMouseMove (e){
                            if (States.orbiting){
                                Orbit.xMove = e.movementX; Orbit.yMove = e.movementY;
                                orbitCamera();
                                renderer.render(scene, camera);
                            }
                        }
                        
                        function onMouseUp (e){
                            Orbit.started = false;
                            Orbit.xFocus = 0;   Orbit.yFocus = 0; 
                            Orbit.xMove = 0;    Orbit.yMove = 0;
                            Orbit.radius = -1;  Orbit.lookAtPoint = null;
                                                      
                            States.orbiting = false;
                        }                    
		</script>
	</body>
</html>
