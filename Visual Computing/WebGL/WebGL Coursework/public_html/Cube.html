<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Cube Manipulation</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
			// Scene Setup
                        var scene = new THREE.Scene();
                        var sceneBackground = scene.background;
                        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                        var renderer = new THREE.WebGLRenderer();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        document.body.appendChild(renderer.domElement);
                        
                        
                        // Event Listeners
                        document.addEventListener("keydown", onKeyDown); //TODO: Pausing cube blocks other events until resumption
                        document.addEventListener("wheel", onWheelScroll);
                        document.addEventListener("mousedown", onMouseDown);
                        document.addEventListener("mousemove", onMouseMove);
                        document.addEventListener("mouseup", onMouseUp);
                        
                        
                        // Default Camera Positioning
                        var defaultCamera = camera.clone();
                        var defaultCameraPos = [2, 1, 7];
                        defaultCamera.position.x = defaultCameraPos[0]; 
                        defaultCamera.position.y = defaultCameraPos[1];
                        defaultCamera.position.z = defaultCameraPos[2];
                        
                        var resetCamera = function () {
                            camera = defaultCamera.clone();                            
                        };
                        
                        resetCamera();  
                        
                        
                        // Cube States                    
                        var CubeStates = {
                            rotating: true,
                            vertexRendering: false,
                            edgeRendering: false, 
                            faceRendering: false, // Inverted initialisation
                            textureRendering: true,
                            orbiting: false
                        };
                        
                    
                        // Cube Setup
                        var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);         
                        var cubeColor = new THREE.Color(0x008B8B);
                        var cubeMaterial = new THREE.MeshBasicMaterial({color: cubeColor, vertexColors: THREE.VertexColors});
                        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        scene.add(cube);
                        
                        
                        // Axes Setup                
                        var xAxisGeometry = new THREE.Geometry();
                        var yAxisGeometry = xAxisGeometry.clone();
                        var zAxisGeometry = xAxisGeometry.clone();
                        var xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
                        var yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                        var zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
                        var axisLength = 20;
                        
                        xAxisGeometry.vertices.push(
                                new THREE.Vector3(-axisLength, 0, 0),
                                new THREE.Vector3(axisLength, 0, 0)
                        );
                
                        yAxisGeometry.vertices.push(
                                new THREE.Vector3(0, -axisLength, 0),
                                new THREE.Vector3(0, axisLength, 0)
                        );
                              
                        zAxisGeometry.vertices.push(
                                new THREE.Vector3(0, 0, -axisLength),
                                new THREE.Vector3(0, 0, axisLength)
                        );
                        
                        var xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
                        var yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
                        var zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
                        
                        scene.add(xAxis, yAxis, zAxis);       
                       
                        
                        // Cube Rotation
                        var animationID; 
                        var rotationStep = 0.01;
                        
                        var rotateX = function() {
                            animationID = requestAnimationFrame(rotateX); 
                            cube.rotation.x += rotationStep;
                            if (cube.rotation.x >= 2*Math.PI){
                                cube.rotation.x = 0;
                                cancelAnimationFrame(animationID); 
                                rotateY();
                            }
                            renderer.render(scene, camera);
                        };
                        
                        var rotateY = function() {
                            animationID = requestAnimationFrame(rotateY);
                            cube.rotation.y += rotationStep;
                            if (cube.rotation.y >= 2*Math.PI){
                                cube.rotation.y = 0;
                                cancelAnimationFrame(animationID); 
                                rotateZ();
                            }
                            renderer.render(scene, camera);
                        };  
                        
                        var rotateZ = function() {
                            animationID = requestAnimationFrame(rotateZ); 
                            cube.rotation.z += rotationStep;
                            if (cube.rotation.z >= 2*Math.PI){
                                cube.rotation.z = 0;
                                cancelAnimationFrame(animationID); 
                                rotateX();
                            }
                            renderer.render(scene, camera);
                        };
                                                                                     
                        rotateX();
                        CubeStates.rotating = true;
                        
                        var toggleCubeAnimation = function() {
                            if (CubeStates.rotating){
                                cancelAnimationFrame(animationID); 
                            } else {
                                if (cube.rotation.y !== 0){
                                    cube.rotation.x = 0;
                                    cube.rotation.z = 0;
                                    rotateY();
                                } else if (cube.rotation.z !== 0){
                                    cube.rotation.x = 0;
                                    cube.rotation.y = 0;
                                    rotateZ();
                                } else { 
                                    cube.rotation.y = 0;
                                    cube.rotation.z = 0;
                                    rotateX();                                 
                                }
                            }
                            CubeStates.rotating = !CubeStates.rotating; 
                        };
                           
                        
                        // Render modes 
                        var cubePointsMaterial = new THREE.PointsMaterial({color: 0xffff00, size:0.1});
                        var cubeWireframeMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true});
                        var cubePoints = new THREE.Points(cubeGeometry, cubePointsMaterial);
                        var cubeWireframe = new THREE.Mesh(cubeGeometry, cubeWireframeMaterial);
                        
                        //cube.add(cubePoints);
                        //cube.add(cubeWireframe);
                        
                        var toggleEdges = function () {
                            if (!CubeStates.edgeRendering){
                                cube.add(cubeWireframe);
                            } else {
                                cube.remove(cubeWireframe);
                            }     
                            CubeStates.edgeRendering = !CubeStates.edgeRendering;   
                        };
                        
                        var toggleFaces = function () {
                            if (!CubeStates.faceRendering){
                                cube.material.opacity = 0.0;
                                cube.material.transparent = true;
                                if (CubeStates.textureRendering){                            
                                    for (var i = 0; i < cube.material.length; i++)
                                    {
                                        cube.material[i].opacity = 0.0;
                                        cube.material[i].transparent = true;
                                    }  
                                }
                            } else {   
                                cube.material.opacity = 1.0;
                                cube.material.transparent = false;
                                if (CubeStates.textureRendering){
                                    for (var i = 0; i < cube.material.length; i++){
                                        cube.material[i].opacity = 1.0;
                                        cube.material[i].transparent = false;
                                    }
                                }
                            }    
                            CubeStates.faceRendering = !CubeStates.faceRendering;
                        };     
    
                        var toggleVertices = function () {
                        if (!CubeStates.vertexRendering){
                                cube.add(cubePoints);
                            } else {
                                cube.remove(cubePoints);
                            }     
                            CubeStates.vertexRendering = !CubeStates.vertexRendering;   
                        };
                             
                             
                        // Camera Translation    
                        // TODO: Change Camera.up and see if up still does the same thing
                        // TODO: Change scrollwheel to zoom on scrollwheel, not z translation
                        var cameraMovementDistance = 0.1;
                        //  camera.up = new THREE.Vector3(1, 0, 0);
                        console.log(camera);
                        
                        var translateCamera = function (direction) {
                            switch (direction){
                                case 'left':
                                    camera.translateX(-cameraMovementDistance);
                                    break;
                                case 'up':
                                    camera.translateY(cameraMovementDistance);
                                    break;
                                case 'right':
                                    camera.translateX(cameraMovementDistance);                              
                                    break;
                                case 'down':
                                    camera.translateY(-cameraMovementDistance);
                                    break;
                                case 'forwards':
                                    camera.translateZ(-cameraMovementDistance);
                                    break;
                                case 'backwards':
                                    camera.translateZ(cameraMovementDistance);
                                    break;
                                default:
                                    break;
                            }
                            
                        };
                       
                        // TODO: orbitcontrols might be a thing
                        // 
                        // Camera Orbit                      
                        var xFocus, yFocus, xMove, yMove;
                        var orbitCamera = function () {
                            /*var x = normalize()
                            console.log(xFocus, yFocus);
                            var up = (camera.position.x - xFocus).normalize();
                            
                            var zFocus = Math.sqrt(xFocus*xFocus + yFocus*yFocus);
                            //camera.lookAt(xFocus, yFocus, zFocus);
                            //camera.rotation.x = xMove*cameraMovementDistance;
                            //camera.rotation.y = (-yMove*cameraMovementDistance);*/
                        };
                        
                        
                        // Cube Texture 
                        var textureNames = ['bronze', 'wire', 'scratched', 'shapes', 'colour', 'water'];
                        var textures = [];
                        var textureLoader = new THREE.TextureLoader();
                        textureLoader.setPath("resources/");
         
                        for (texture in textureNames){                          
                            textures.push(new THREE.MeshBasicMaterial({
                                map: textureLoader.load(textureNames[texture] + '.jpg')
                            }));
                        }
                        
                        // Use textured material by default
                        cube.material = textures;
                        CubeStates.textureRendering = true;
                        
                        var toggleTextures = function() {
                            if (!CubeStates.textureRendering){
                                cube.material = textures;
                            } else {
                                cube.material = cubeMaterial;
                            }
                            CubeStates.faceRendering = true;
                            CubeStates.textureRendering = !CubeStates.textureRendering; 
                            toggleFaces();
                         };
                         
                         
                        // Event Handlers
                        
                        // Key press event handler
                        function onKeyDown(e){
                            switch(e.which){
                                // Pause cube rotation
                                case 32:
                                    toggleCubeAnimation();
                                    break;
                                // Move camera left on left arrow KeyDown
                                case 37:
                                    translateCamera('left');
                                    break;
                                // Move camera up on up arrow KeyDown
                                case 38:
                                    translateCamera('up');
                                    break;
                                // Move camera right on right arrow KeyDown
                                case 39:                            
                                    translateCamera('right');
                                    break; 
                                // Move camera down on down arrow KeyDown
                                case 40:
                                    translateCamera('down');
                                    break;                                
                                // Move camera forwards on '+' KeyDown; can also be invoked by using the mousewheel
                                case 107:
                                    translateCamera('forwards');
                                    break;                                
                                // Move camera backwards '-' KeyDown; can also be invoked by using the mousewheel
                                case 109:
                                    translateCamera('backwards');
                                    break;
                                // Reset camera position on 'r' KeyDown
                                case 82:
                                    resetCamera();
                                    break;
                                // Toggle cube edge rendering (inc. primitive triangles) on 'e' KeyDown
                                case 69:
                                    toggleEdges();
                                    break;
                                // Toggle cube faces on 'f' KeyDown
                                case 70: 
                                    toggleFaces();
                                    break;                      
                                // Toggle cube vertex rendering on 'v' KeyDown
                                case 86: 
                                    toggleVertices();
                                    break;       
                                // Apply textures on 't' KeyDown
                                case 84: 
                                    toggleTextures();
                                    break; 
                                default:
                                    break;                            
                            }
                        }
                        
                        // Scroll wheel event handler 
                        // Used to zoom camera in and out via the scroll wheel
                        function onWheelScroll(e){                        
                           if (e.wheelDelta > 0){
                                camera.position.z -= cameraMovementDistance;
                            } else {
                                camera.position.z += cameraMovementDistance;
                            }
                            //console.log(camera.zoom);
                        }
                        
                        function onMouseDown(e){
                            if (e.which === 1){
                                xFocus = e.x; yFocus = e.y;
                                CubeStates.orbiting = true;
                            }
                        }
                        
                        function onMouseMove(e){
                            if (CubeStates.orbiting){
                                xMove = e.movementX;  yMove = e.movementY;
                                orbitCamera();
                            }
                        }
                        
                        function onMouseUp(e){
                            xFocus = 0; yFocus = 0; xMove = 0; yMove = 0;
                            CubeStates.orbiting = false;
                        }                    
		</script>
	</body>
</html>
